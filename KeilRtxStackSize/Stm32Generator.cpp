// This file is part of KeilMapLib.
//
// KeilMapLib is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KeilMapLib is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with KeilMapLib.  If not, see <https://www.gnu.org/licenses/>.

#include "stdafx.h"
#include "Stm32Generator.h"

/*****************************************************************************/
Stm32Generator::Stm32Generator()
/*****************************************************************************/
{
}

/*****************************************************************************/
Stm32Generator::~Stm32Generator()
/*****************************************************************************/
{
}

/*****************************************************************************/
void Stm32Generator::Generate(PARAMETERS &parameters)
/*****************************************************************************/
{
	std::vector<std::string> task_list;
	boost::regex             regex(parameters.thread_regex);

	_Header_File.clear();

	_Header_File.emplace_back("#ifndef _KEIL_RTX_STACK_SIZE_H");
	_Header_File.emplace_back("#define _KEIL_RTX_STACK_SIZE_H");
	_Header_File.emplace_back("");
	_Header_File.emplace_back("/// @brief Generated by " + App_Name + " " + App_Version);
	_Header_File.emplace_back("///");
	_Header_File.emplace_back("/// This solution can't trace:");
	_Header_File.emplace_back("/// - function pointer");
	_Header_File.emplace_back("/// - recursive functions");
	_Header_File.emplace_back("///");
	_Header_File.emplace_back("/// Stack oversizing is user demaned");
	_Header_File.emplace_back("/// For example:");
	_Header_File.emplace_back("///     static const osThreadAttr_t Generic_Thread_Attributes = { .priority = osPriorityNormal, .stack_size = (GENERIC_TASK_STACK_SIZE + 100) };");
	_Header_File.emplace_back("///     to add 100 extra bytes to manage recursion or function pointer");
	_Header_File.emplace_back("");
	_Header_File.emplace_back("#if defined(STM32G0)");
	_Header_File.emplace_back("#define " + Pad("SYSTEM_ARCHITECTURE_STACK_USAGE", 64) + " (64)");
	_Header_File.emplace_back("#elif defined(STM32F1)");
	_Header_File.emplace_back("#define " + Pad("SYSTEM_ARCHITECTURE_STACK_USAGE", 64) + " (0)");
	_Header_File.emplace_back("#elif defined(STM32F4)");
	_Header_File.emplace_back("#define " + Pad("SYSTEM_ARCHITECTURE_STACK_USAGE", 64) + " (128)");
	_Header_File.emplace_back("#else");
	_Header_File.emplace_back("#error Unable to recognise architecture: contact " + App_Author + " and ask an improvement!");
	_Header_File.emplace_back("#define " + Pad("SYSTEM_ARCHITECTURE_STACK_USAGE", 64) + " (0)");
	_Header_File.emplace_back("#endif");
	_Header_File.emplace_back("");
	_Header_File.emplace_back("/******************************************************************************/");
	_Header_File.emplace_back("");

	for (MAXIMUM_STACK_USAGE_FIELD field : _Maximum_Stack_Usage)
	{
		size_t      size;
		std::string name;

		if (boost::regex_search(field.function, regex))
		{
			if (std::find(task_list.begin(), task_list.end(), field.function) == task_list.end())
			{
				task_list.emplace_back(field.function);

				_Header_File.emplace_back("// " + field.call_chain);
				name = field.function;
				try
				{
					size = std::stol (field.size, 0, 16);
				}
				catch (...)
				{
					size = 0;
				}

				std::transform(name.begin(), name.end(), name.begin(), ::toupper);
				name += "_STACK_SIZE";
				size = CalculareStackSize(size, STM32_STDIO_DEFAULT_STACK_SIZE, parameters.stack_oversizing);

				_Header_File.emplace_back("#define " + Pad(name.c_str(), 64) + " (SYSTEM_ARCHITECTURE_STACK_USAGE + " + std::to_string(size) + ")");
				_Header_File.emplace_back("");
			}
		}
	}

	for (STACK_USAGE_FIELD field : _Stack_Usage)
	{
		size_t      size;
		std::string name;
		if (boost::regex_search(field.function, regex))
		{
			if (std::find(task_list.begin(), task_list.end(), field.function) == task_list.end())
			{
				task_list.emplace_back(field.function);

				_Header_File.emplace_back("// CALL CHAIN NOT AVAILABLE");
				name = field.function;
				try
				{
					size = std::stol (field.size, 0, 16);
				}
				catch (...)
				{
					size = 0;
				}

				std::transform(name.begin(), name.end(), name.begin(), ::toupper);
				name += "_STACK_SIZE";
				size = CalculareStackSize(size, STM32_STDIO_DEFAULT_STACK_SIZE, parameters.stack_oversizing);

				_Header_File.emplace_back("#define " + Pad(name.c_str(), 64) + " (SYSTEM_ARCHITECTURE_STACK_USAGE + " + std::to_string(size) + ")");
				_Header_File.emplace_back("");
			}
		}
	}

	_Header_File.emplace_back("#endif");
}
